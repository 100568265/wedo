cscope 15 $HOME/wedo/protocols/txjprotocolmodbusrtu_zhu_ZGDZ_06               0000038697
	@/home/zengrong/wedo/protocols/txjprotocolmodbusrtu_zhu_ZGDZ_06/include/CModbusRTU.h

1 #i‚de‡
CMODBUSRTU_H


2 
	#CMODBUSRTU_H


	)

4 
	~"PrŸocﬁ.h
"

5 
	~"D©aCache.h
"

6 
	~"Devi˚.h
"

7 
	~"Devi˚s.h
"

8 
	~"sysöifûe.h
"

11 #ifde‡
PROTOCOL_EXPORTS


12 
	#PROTOCOL_API
 
	`__de˛•ec
(
dŒexp‹t
)

	)

14 
	#PROTOCOL_API
 
	`__de˛•ec
(
dŒimp‹t
)

	)

17 #ifde‡
__˝lu•lus


21 
usög
 
«me•a˚
 
°d
;

23 ˛as†
	cCModbusRTU
 : 
public
 
PrŸocﬁ


25 
public
:

26 
CModbusRTU
();

27 
vútuÆ
 ~
CModbusRTU
();

28 
Inô
();

29 
Unöô
();

30 
OnRód
(
ST_BYTE
* 
pbuf
,
ST_INT
& 
ªaded
);

31 
ST_BOOLEAN
 
OnSíd
();

32 
ST_BOOLEAN
 
OnPro˚ss
(
ST_BYTE
* 
pbuf
,
ST_INT
 
Àn
);

33 
ST_BOOLEAN
 
IsSuµ‹tEngöe
(
ST_INT
 
ígöeTy≥
);

34 
¥Ÿe˘ed
:

35 
¥iv©e
:

36 
SídRódCmd
(
ST_BYTE
 
code
, 
ST_UINT
 
ªadAddr
,ST_UINT 
cou¡
);

37 
SídWrôeCmd
(
ST_UCHAR
* 
pD©a
,
ST_UINT
 
d©aLí
,ST_UINT 
addr
);

38 
SídSögÀWrôeCmd
(
ST_INT
 
d©a
,ST_INT 
ªadAddr
,ST_INT 
nTy≥
);

39 
SídYK
(
ST_UINT
 
wrôeAddr
,
ST_INT
 
d©a
);

40 
SídPªYK
(
ST_UINT
 
wrôeAddr
,
ST_BOOLEAN
 
bIsOn
);

41 
SídYT
(
ST_UINT
 
wrôeAddr
,ST_UINT 
wIndex
,
ST_BOOLEAN
 
bIsOn
);

42 
Pro˚ssMem‹y
(
ST_BYTE
* 
buf
,ST_BYTE 
cou¡
);

60 
Pro˚ssMem‹ySByã
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

61 
Pro˚ssMem‹yI¡16
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

62 
Pro˚ssMem‹yI¡32
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

63 
Pro˚ssMem‹yByã
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

64 
Pro˚ssMem‹yUI¡16
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

65 
Pro˚ssMem‹yUI¡32
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

66 
Pro˚ssMem‹ySögÀ
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

67 
Pro˚ssMem‹yBoﬁón
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

68 
Pro˚ssMem‹ySåög
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

69 
Pro˚ssMem‹yByãs
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

70 
Pro˚ssMem‹yDoubÀ
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

71 
Pro˚ssMem‹yDecimÆ
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

72 
Pro˚ssMem‹yD©eTime
(
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

73 
Pro˚ssMem‹yI¡64
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

74 
Pro˚ssMem‹yUI¡64
 (
ST_BYTE
*, c⁄° 
ST_D©aAªaIãm
&);

76 
FûlWORD
(
ST_BYTE
* 
buf
,
ST_UINT
 
v
);

78 
ST_UINT32
 
ht⁄l1
(ST_UINT32 
dv
);

79 
ST_UINT
 
GëAµWORDVÆue
(ST_UINT 
v
,
ST_INT
 
codëy≥
);

81 
SídWrôeCmd
(
ST_UCHAR
* 
pD©a
,
ST_UINT
 
d©aLí
);

82 
SídWrôeCmdHex
(
ST_UCHAR
* 
pD©a
,
ST_UINT
 
d©aLí
);

84 
ST_BOOLEAN
 
m_bTask
;

85 
PrŸocﬁTask
 
m_curTask
;

86 
ST_INT
 
m_cuºódIndex
;

87 
ST_INT
 
m_ªadIndex
;

90 #ifde‡
_WIN32


91 
PROTOCOL_API
 
CModbusRTU
* 
Cª©eIn°a˚
();

93 
CModbusRTU
* 
Cª©eIn°a˚
();

96 #ifde‡
__˝lu•lus


	@/home/zengrong/wedo/protocols/txjprotocolmodbusrtu_zhu_ZGDZ_06/src/CModbusRTU.cpp

1 
	~"CModbusRTU.h
"

2 
	~"sy¶oggî.h
"

3 
	~"Debug.h
"

4 
	~"Ch™√l.h
"

6 
	#sDebug
 i‡(
åue
Ë
	`wedoDebug
 (
SysLoggî
::
	`GëIn°™˚
()).
noquŸe


	)

8 c⁄° 
uöt16_t
 
	g¸c16_èbÀ
[256] =

44 
ölöe
 
ST_BYTE
 
	$FromBCD_BYTE
(
ST_BYTE
 
vÆue
)

46  ((
vÆue
 & 0xF0) >> 4) * 10 + (value & 0x0F);

47 
	}
}

49 
ST_UINT16
 
	$FromBCD_WORD
(
ST_UINT16
 
vÆue
)

51  (
ST_UINT16
)
	`FromBCD_BYTE
((
vÆue
 & 0xFF00) >> 8) * 100 + (ST_UINT16)FromBCD_BYTE(value & 0x00FF);

52 
	}
}

54 
ST_UINT32
 
	$FromBCD_DWORD
(
ST_UINT32
 
vÆue
)

56  (
ST_UINT32
)
	`FromBCD_WORD
((
vÆue
 & 0xFFFF0000) >> 16) * 10000 + (ST_UINT32)FromBCD_WORD(value & 0x0000FFFF);

57 
	}
}

59 
ölöe
 
ST_BYTE
 
	$TOBCD_BYTE
(
ST_BYTE
 
vÆue
)

61  ((
vÆue
 / 10) << 4) + (value % 10);

62 
	}
}

64 
ST_UINT16
 
	$TOBCD_WORD
(
ST_UINT16
 
vÆue
)

66  ((
ST_UINT16
)
	`TOBCD_BYTE
((
vÆue
 & 0xFF00) >> 8) << 8) + (ST_UINT16)TOBCD_BYTE(value & 0x00FF);

67 
	}
}

69 
ST_UINT32
 
	$TOBCD_DWORD
(
ST_UINT32
 
vÆue
)

71  ((
ST_UINT32
)
	`TOBCD_WORD
((
vÆue
 & 0xFFFF0000) >> 16) << 16) + (ST_UINT32)TOBCD_WORD(value & 0x0000FFFF);

72 
	}
}

84 
uöt16_t
 
	$gë_¸c16
 (c⁄° 
uöt8_t
 *
pd©a
, 
nsize
)

86 
uöt16_t
 
¸c
 = 0xFFFF;

87 
nsize
-- > 0)

88 
¸c
 = 
¸c16_èbÀ
[(¸¯& 0xFFË^ (*
pd©a
++)] ^ (crc >> 8);

89  
¸c
;

90 
	}
}

92 ˛as†
	cc⁄vît


94 
	mpublic
:

96 
ãm∂©e
<
ty≥«me
 
T
>

97 
T
 
	$byãs_to
 (c⁄° * 
byãs
, 
size_t
 
Àn
)

99 
T
 
vÆue
;

100 
	`mem˝y
 (&
vÆue
, 
byãs
, 
	`mö
((
T
), 
Àn
));

101  
vÆue
;

104 
	}
};

108 
	gCModbusRTU
::
	$CModbusRTU
()

111 
	}
}

113 
CModbusRTU
::~
	$CModbusRTU
()

116 
	}
}

118 
CModbusRTU
* 
	$Cª©eIn°a˚
()

120  
√w
 
	`CModbusRTU
();

121 
	}
}

123 
ST_BOOLEAN
 
	gCModbusRTU
::
	$IsSuµ‹tEngöe
(
ST_INT
 
ígöeTy≥
)

126 
	}
}

128 
	gCModbusRTU
::
	$Inô
()

130 
m_bTask
 = 
Ál£
;

131 
m_cuºódIndex
 = 0;

132 
m_ªadIndex
 = 0;

133 
	}
}

135 
	gCModbusRTU
::
	$Unöô
()

138 
	}
}

139 
CModbusRTU
::
	$OnRód
(
ST_BYTE
* 
pbuf
,
ST_INT
& 
ªaded
)

141 
ªaded
 = 0;

142 if(! 
this
->
	`GëCurP‹t
())

144 if(
m_cuºódIndex
 < 0 || m_cuºódIndex >
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
D©aAªasCou¡
)

146 
	`ShowMesßge
 ("No configuration deviceÅemplate.");

147 
m_cuºódIndex
 = 0;

148 
this
->
	`GëCurP‹t
()->
	`CÀ¨
();

151 
ST_INT
 
öãrvÆ
 = 
this
->
	`GëDevi˚
()->
	`GëCh™√l
()->
	`GëCh™√lInfo
()->
Ch™√lI¡îvÆ
;

152 
öãrvÆ
 = (interval > 2000 ? interval : 2000);

154 
ST_INT
 
Àn
 = 
this
->
	`GëCurP‹t
()->
	`PickByãs
(
pbuf
, 5, 
öãrvÆ
);

155 if(
Àn
 < 5) {

156 
	`ShowMesßge
 ("Insufficient dataÜength");

157 
this
->
	`GëCurP‹t
()->
	`CÀ¨
();

160 
ST_INT
 
°¨
 = 0;

161 ; 
°¨
 < 
Àn
; ++star) {

162 if(
pbuf
[
°¨
] =(
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
Addªss
)

165 if(
°¨
 > 0) {

167 
this
->
	`GëCurP‹t
()->
	`RódByãs
(
pbuf
, 
°¨
);

169 if(
°¨
 =
Àn
) {

171 
	`ShowMesßge
 ("Garbled code, clear buffer.");

172 
this
->
	`GëCurP‹t
()->
	`CÀ¨
();

175 
Àn
 = 
this
->
	`GëCurP‹t
()->
	`PickByãs
(
pbuf
, 5, 2000);

176 
ST_BYTE
 
fuccode
 = 
pbuf
[1 + 
°¨
];

177 if((
fuccode
 & 0xF0) == 0x80)

179 
Àn
 = 5;

181 if(
fuccode
 == 0x05)

183 
Àn
 = 8;

185 if(
fuccode
 == 0x10)

187 
Àn
 = 8;

189 if(
fuccode
 == 0x06)

191 
Àn
 = 8;

193 if(
fuccode
 =(
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
D©aAªas
[
m_cuºódIndex
].
ªadCode
)

196 
ST_BYTE
 
ªadCou¡
 = 
pbuf
[2 + 
°¨
];

197 
Àn
 = 
ªadCou¡
 + 5;

199 if(
fuccode
 =(
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
D©aAªas
[
m_cuºódIndex
].
wrôeCode
)

202 
Àn
 = 8;

206 
	`ShowMesßge
 ("Not Found Function Code!");

207 
this
->
	`GëCurP‹t
()->
	`CÀ¨
();

210 
ST_INT
 
∆í
 = 
this
->
	`GëCurP‹t
()->
	`PickByãs
(
pbuf
, 
Àn
, 2000);

211 if(
∆í
 =
Àn
)

213 
this
->
	`GëCurP‹t
()->
	`RódByãs
(
pbuf
, 
Àn
);

214 
ST_UINT16
 
wCRC
 = 
	`gë_¸c16
(&
pbuf
[0], 
Àn
-2);

215 
ST_UINT16
 
nCRC
 = 
pbuf
[
Àn
-2] +Öbuf[len-1] * 256;

216 if(
wCRC
 =
nCRC
)

218 
ªaded
 = 
Àn
;

230 
	`ShowMesßge
 ("Insufficient dataÜength.");

231 
this
->
	`GëCurP‹t
()->
	`CÀ¨
();

233 
	}
}

235 
ST_BOOLEAN
 
	gCModbusRTU
::
	$OnSíd
()

237 i‡(
this
->
	`GëCurP‹t
())

238 
this
->
	`GëCurP‹t
()->
	`CÀ¨
();

240 
m_bTask
 = 
Ál£
;

241 if(
this
->
	`HasTask
(Ë&&Åhis->
	`GëTask
(&
m_curTask
))

243 if(!
	`°rcmp
(
m_curTask
.
èskCmd
,"singleread"))

246 
msg
[64];

247 
	`•rötf
(
msg
,"m_curTask.èskAdd∏: %d",
m_curTask
.
èskAddr
);

248 
	`ShowMesßge
(
msg
);

249 
	`SídRódCmd
((
ST_BYTE
)0x03,
m_curTask
.
èskAddr
,0x01);

250 
m_bTask
 = 
åue
;

252 if(!
	`°rcmp
(
m_curTask
.
èskCmd
,"devicecontrol"))

254 if(
m_curTask
.
èskCmdCode
 == 0)

255 
	`SídPªYK
(
m_curTask
.
èskAddr
,m_curTask.
èskVÆue
);

256 if(
m_curTask
.
èskCmdCode
 == 1)

257 
	`SídYK
(
m_curTask
.
èskAddr
,m_curTask.
èskVÆue
);

258 if(
m_curTask
.
èskCmdCode
 == 2)

259 
	`SídRódCmd
((
ST_BYTE
)
m_curTask
.
èskCmdCode
,m_curTask.
èskAddr
,m_curTask.
èskAddr1
);

262 
m_curTask
.
èskResu…
.
ªsu…Code
 = 0;

263 
m_curTask
.
isTøns„r
 = 1;

264 
	`Tøns„r
(&
m_curTask
);

265 
	`mem£t
(&
m_curTask
,0,(m_curTask));

266  
Ál£
;

268 
m_bTask
 = 
åue
;

270 if(!
	`°rcmp
(
m_curTask
.
èskCmd
,"singlewrite"))

280 
¡y≥
 = 0;

281 if(
m_curTask
.
èskAddr
 =0x0D00Ë
¡y≥
 = 1;

282 
	`SídSögÀWrôeCmd
((
ST_INT
)
m_curTask
.
èskVÆue
,m_curTask.
èskAddr
,
¡y≥
);

283 
m_bTask
 = 
åue
;

285 if(!
	`°rcmp
(
m_curTask
.
èskCmd
,"multiwrite"))

288 
	`SídWrôeCmd
(
m_curTask
.
èskP¨am
,m_curTask.
èskP¨amLí
,m_curTask.
èskAddr
);

289 
m_bTask
 = 
åue
;

291  
åue
;

293 c⁄° 
Devi˚Info
* 
öfo
 = 
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
();

294 if(
öfo
 && info->
D©aAªasCou¡
 > 0)

296 i‡(
m_ªadIndex
 >
öfo
->
D©aAªasCou¡
)

297 
m_ªadIndex
 = 0;

298 
m_cuºódIndex
 = 
m_ªadIndex
++;

299 
	`SídRódCmd
(
öfo
->
D©aAªas
[
m_cuºódIndex
].
ªadCode
, (
ST_UINT16
)öfo->D©aAªas[m_cuºódIndex].
addr
,

300 
öfo
->
D©aAªas
[
m_cuºódIndex
].
d©aUnôLí
 > 1 ?

301 
öfo
->
D©aAªas
[
m_cuºódIndex
].
Àn
 / info->D©aAªas[m_cuºódIndex].
d©aUnôLí
 : info->DataAreas[m_curreadIndex].len);

303  
åue
;

304 
	}
}

306 
ST_BOOLEAN
 
	gCModbusRTU
::
	$OnPro˚ss
(
ST_BYTE
* 
pbuf
,
ST_INT
 
Àn
)

308 if(
m_bTask
)

310 if(!
	`°rcmp
(
m_curTask
.
èskCmd
,"singlewrite") || !strcmp(m_curTask.taskCmd,"multiwrite"))

312 
	`ShowMesßge
("receive singlewirte order");

313 
m_curTask
.
èskResu…
.
ªsu…Code
 = 0;

314 
m_curTask
.
isTøns„r
 = 1;

315 
	`Tøns„r
(&
m_curTask
);

316 
	`Mem£t
(&
m_curTask
, 0, (m_curTask));

317  
åue
;

319 if(!
	`°rcmp
(
m_curTask
.
èskCmd
,"devicecontrol"))

321 
m_curTask
.
èskResu…
.
ªsu…Code
 = 0;

322 
m_curTask
.
isTøns„r
 = 1;

323 
	`Tøns„r
(&
m_curTask
);

324 
	`Mem£t
(&
m_curTask
, 0, (m_curTask));

325  
åue
;

327 if(!
	`°rcmp
(
m_curTask
.
èskCmd
,"singleread"))

329 
m_curTask
.
èskResu…
.
ªsu…Code
 = 0;

330 
m_curTask
.
èskResu…
.
ªsu…D©aLí
 = 
pbuf
[2];

331 
m_curTask
.
èskResu…
.
ªsu…VÆue
 = ()(
pbuf
[3]*256 +Öbuf[4]);

332 
	`mem˝y
(
m_curTask
.
èskResu…
.
ªsu…D©a
,&
pbuf
[3],m_curTask.èskResu….
ªsu…D©aLí
);

333 
msg
[64];

334 
	`•rötf
(
msg
,"ªsu… vÆuê:%f",
m_curTask
.
èskResu…
.
ªsu…VÆue
);

335 
	`ShowMesßge
(
msg
);

336 
m_curTask
.
isTøns„r
 = 1;

337 
	`Tøns„r
(&
m_curTask
);

338 
	`Mem£t
(&
m_curTask
, 0, (m_curTask));

339  
åue
;

343 
m_curTask
.
èskResu…
.
ªsu…Code
 = 0;

344 
m_curTask
.
isTøns„r
 = 1;

345 
	`Tøns„r
(&
m_curTask
);

346 
	`Mem£t
(&
m_curTask
, 0, (m_curTask));

347  
åue
;

350 if(
m_cuºódIndex
 >0 && m_cuºódIndex < 
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
D©aAªasCou¡


351 && 
pbuf
[1] =(
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
D©aAªas
[
m_cuºódIndex
].
ªadCode
)

353 
ST_BYTE
 
cou¡
 = 
pbuf
[2];

354 
	`Pro˚ssMem‹y
(&
pbuf
[3], 
cou¡
);

356  
åue
;

357 
	}
}

359 
	gCModbusRTU
::
	$Pro˚ssMem‹y
(
ST_BYTE
* 
buf
, ST_BYTE 
cou¡
)

361 
ST_INT
 
ôemsize
 = 
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
D©aAªas
[
m_cuºódIndex
].
ôemCou¡
;

362 
ST_INT
 
k
 = 0; k < 
ôemsize
; k++)

364 c⁄° 
ST_D©aAªaIãm
& 
ôemªf
 = 
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
D©aAªas
[
m_cuºódIndex
].
ôems
[
k
];

365 if(
cou¡
 < (
ôemªf
.
addr
 + iãmªf.
d©aLí
))

368 
ôemªf
.
d©aTy≥
) {

369 
VALTy≥_Ch¨
 :

370 
VALTy≥_SByã
:

371 
	`Pro˚ssMem‹ySByã
 (
buf
, 
ôemªf
); ;

372 
VALTy≥_I¡16
:

373 
	`Pro˚ssMem‹yI¡16
 (
buf
, 
ôemªf
); ;

374 
VALTy≥_I¡32
:

375 
	`Pro˚ssMem‹yI¡32
 (
buf
, 
ôemªf
); ;

376 
VALTy≥_Byã
 :

377 
	`Pro˚ssMem‹yByã
 (
buf
, 
ôemªf
); ;

378 
VALTy≥_UI¡16
:

379 
	`Pro˚ssMem‹yUI¡16
 (
buf
, 
ôemªf
); ;

380 
VALTy≥_UI¡32
:

381 
	`Pro˚ssMem‹yUI¡32
 (
buf
, 
ôemªf
); ;

382 
VALTy≥_Flﬂt
:

383 
	`Pro˚ssMem‹ySögÀ
 (
buf
, 
ôemªf
); ;

384 
VALTy≥_Boﬁón
:

385 
	`Pro˚ssMem‹yBoﬁón
 (
buf
, 
ôemªf
); ;

386 
VALTy≥_Såög
:

387 
	`Pro˚ssMem‹ySåög
 (
buf
, 
ôemªf
); ;

388 
VALTy≥_Bö¨y
:

389 
	`Pro˚ssMem‹yByãs
 (
buf
, 
ôemªf
); ;

390 
VALTy≥_DoubÀ
:

391 
	`Pro˚ssMem‹yDoubÀ
 (
buf
, 
ôemªf
); ;

392 
VALTy≥_DecimÆ
:

393 
	`Pro˚ssMem‹yDecimÆ
 (
buf
, 
ôemªf
); ;

394 
VALTy≥_D©eTime
:

395 
	`Pro˚ssMem‹yD©eTime
 (
buf
, 
ôemªf
); ;

396 
VALTy≥_I¡64
:

397 
	`Pro˚ssMem‹yI¡64
 (
buf
, 
ôemªf
); ;

398 
VALTy≥_UI¡64
:

399 
	`Pro˚ssMem‹yUI¡64
 (
buf
, 
ôemªf
); ;

403 
	}
}

405 
ölöe
 
ST_UINT16
 
	$bsw≠16
 (
ST_UINT16
 
vÆue
)

407  (((
vÆue
 & 0x00FF) << 8) | ((value & 0xFF00) >> 8));

408 
	}
}

409 
ölöe
 
ST_UINT32
 
	$bsw≠32
 (
ST_UINT32
 
vÆue
)

411  (((
ST_UINT32
)
	`bsw≠16
(
vÆue
 & 0x0000FFFF) << 16) | bswap16((value & 0xFFFF0000) >> 16));

412 
	}
}

413 
ölöe
 
ST_UINT64
 
	$bsw≠64
 (
ST_UINT64
 
vÆue
)

415  (((
ST_UINT64
)
	`bsw≠32
(
vÆue
 & 0x00000000FFFFFFFF) << 32) | bswap32((value & 0xFFFFFFFF00000000) >> 32));

416 
	}
}

417 
ölöe
 
ST_UINT32
 
	$wsw≠32
 (
ST_UINT32
 
vÆue
)

419  (((
vÆue
 & 0x0000FFFF) << 16) | ((value & 0xFFFF0000) >> 16));

420 
	}
}

421 
ölöe
 
ST_UINT64
 
	$wsw≠64
 (
ST_UINT64
 
vÆue
)

423  (((
ST_UINT64
)
	`wsw≠32
(
vÆue
 & 0x00000000FFFFFFFF) << 32) | wswap32((value & 0xFFFFFFFF00000000) >> 32));

424 
	}
}

426 
	gCModbusRTU
::
	$Pro˚ssMem‹ySByã
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

428 if(
ôemªf
.
d©aLí
 == 1)

430 
ST_BYTE
 
vÆue
 = *(
buf
 + 
ôemªf
.
addr
);

431 if(
ôemªf
.
ídBô
 - iãmªf.
begöBô
 < 7)

433 
vÆue
 = (vÆuê& (0xFF << (
ôemªf
.
begöBô
 -1))Ë& (0xFF >> (8 - iãmªf.
ídBô
));

434 
vÆue
 = vÆuê>> (
ôemªf
.
begöBô
 - 1);

436 if(
ôemªf
.
c€ficõ¡
 < 0)

438 
vÆue
 = !value;

440 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, (
ST_BYTE
)
vÆue
);

447 if(
ôemªf
.
d©aLí
 == 2)

449 
ST_INT16
 
vÆue
 = 0x0000;

450 if((
ôemªf
.
codeTy≥
 == 1))

452 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
,  (value));

453 *((
ST_UINT16
*)&
vÆue
Ë
	`bsw≠16
(*((ST_UINT16*)&value));

457 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
,  (value));

459 if(
ôemªf
.
ídBô
 - iãmªf.
begöBô
 < 15)

461 
vÆue
 = (vÆuê& (0xFFFF << (
ôemªf
.
begöBô
 -1))Ë& (0xFFFF >> (16 - iãmªf.
ídBô
));

462 
vÆue
 = vÆuê>> (
ôemªf
.
begöBô
 - 1);

464 if(
ôemªf
.
c€ficõ¡
 < 0)

466 
vÆue
 = !value;

468 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, (
ST_BYTE
)
vÆue
);

470 
	}
}

472 
	gCModbusRTU
::
	$Pro˚ssMem‹yI¡16
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

474 
ST_FLOAT
 
fvÆue
 = 0;

475 if(
ôemªf
.
d©aLí
 == 1)

477 
ST_BYTE
 
vÆue
 = *(
buf
 + 
ôemªf
.
addr
);

478 if((
ôemªf
.
codeTy≥
 == 2) || (itemref.codeType == 3))

480 
fvÆue
 = 
	`FromBCD_BYTE
(
vÆue
);

482 
fvÆue
 = (
ST_FLOAT
)(*((
ST_CHAR
*)&
vÆue
));

484 if(
ôemªf
.
d©aLí
 == 2)

486 if((
ôemªf
.
codeTy≥
 == 2))

488 
ST_UINT16
 
vÆue
 = 0;

489 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

490 
vÆue
 = 
	`FromBCD_WORD
(value);

491 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT16
*)&
vÆue
));

493 if((
ôemªf
.
codeTy≥
 == 3))

495 
ST_UINT16
 
vÆue
 = 0;

496 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

497 
vÆue
 = 
	`FromBCD_WORD
(
	`bsw≠16
(value));

498 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT16
*)&
vÆue
));

500 if((
ôemªf
.
codeTy≥
 == 0))

502 
ST_UINT16
 
vÆue
 = 0;

503 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

504 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT16
*)&
vÆue
));

506 if((
ôemªf
.
codeTy≥
 == 1))

508 
ST_UINT16
 
vÆue
 = 0;

509 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

510 
vÆue
 = 
	`bsw≠16
(value);

511 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT16
*)&
vÆue
));

514 if(
ôemªf
.
d©aLí
 == 4)

516 if((
ôemªf
.
codeTy≥
 == 2))

518 
ST_UINT32
 
vÆue
 = 0;

519 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

520 
vÆue
 = 
	`FromBCD_DWORD
(value);

521 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT32
*)&
vÆue
));

523 if((
ôemªf
.
codeTy≥
 == 3))

525 
ST_UINT32
 
vÆue
 = 0;

526 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

527 
vÆue
 = 
	`FromBCD_DWORD
(
	`bsw≠32
(value));

528 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT32
*)&
vÆue
));

530 if((
ôemªf
.
codeTy≥
 == 0))

532 
ST_UINT32
 
vÆue
 = 0;

533 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

534 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT32
*)&
vÆue
));

536 if((
ôemªf
.
codeTy≥
 == 1))

538 
ST_UINT32
 
vÆue
 = 0;

539 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

540 
vÆue
 = 
	`bsw≠32
(value);

541 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT32
*)&
vÆue
));

543 if((
ôemªf
.
codeTy≥
 == 4))

545 
ST_UINT32
 
vÆue
 = 0;

546 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

547 
vÆue
 = 
	`ht⁄l1
(value);

548 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT32
*)&
vÆue
));

550 if((
ôemªf
.
codeTy≥
 == 5))

552 
ST_UINT32
 
vÆue
 = 0;

553 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

554 
vÆue
 = 
	`wsw≠32
(value);

555 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT32
*)&
vÆue
));

557 if((
ôemªf
.
codeTy≥
 == 6))

559 
ST_UINT32
 
vÆue
 = 0;

560 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

561 
ST_UINT16
* 
dvÆue
 = (ST_UINT16*)&
vÆue
;

562 
fvÆue
 = (
ST_FLOAT
)(
dvÆue
[1]*10000 + dvalue[0]);

565 if(
ôemªf
.
d©aLí
 == 8)

567 if((
ôemªf
.
codeTy≥
 == 10))

569 
ST_UINT64
 
vÆue
 = 0;

570 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

571 
ST_UINT16
* 
dvÆue
 = (ST_UINT16*)&
vÆue
;

572 
fvÆue
 = (
ST_FLOAT
)(
	`bsw≠16
(
dvÆue
[3])*1000000000000 + bswap16(dvalue[2])*100000000 + bswap16(dvalue[1])*10000 + bswap16(dvalue[0]));

575 if(
ôemªf
.
c€ficõ¡
 != 0)

577 
fvÆue
 = fvÆuê* 
ôemªf
.
c€ficõ¡
;

579 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, 
fvÆue
);

581 
	}
}

583 
	gCModbusRTU
::
	$Pro˚ssMem‹yI¡32
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

585 
ST_DOUBLE
 
fvÆue
 = 0;

586 if(
ôemªf
.
d©aLí
 == 1)

588 
ST_BYTE
 
vÆue
 = *(
buf
 + 
ôemªf
.
addr
);

589 if((
ôemªf
.
codeTy≥
 == 2) || (itemref.codeType == 3))

591 
fvÆue
 = 
	`FromBCD_BYTE
(
vÆue
);

593 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_CHAR
*)&
vÆue
));

595 if(
ôemªf
.
d©aLí
 == 2)

597 if((
ôemªf
.
codeTy≥
 == 2))

599 
ST_UINT16
 
vÆue
 = 0;

600 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

601 
vÆue
 = 
	`FromBCD_WORD
(value);

602 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT16
*)&
vÆue
));

604 if((
ôemªf
.
codeTy≥
 == 3))

606 
ST_UINT16
 
vÆue
 = 0;

607 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

608 
vÆue
 = 
	`FromBCD_WORD
(
	`bsw≠16
(value));

609 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT16
*)&
vÆue
));

611 if((
ôemªf
.
codeTy≥
 == 0))

613 
ST_UINT16
 
vÆue
 = 0;

614 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

615 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT16
*)&
vÆue
));

617 if((
ôemªf
.
codeTy≥
 == 1))

619 
ST_UINT16
 
vÆue
 = 0;

620 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

621 
vÆue
 = 
	`bsw≠16
(value);

622 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT16
*)&
vÆue
));

625 if(
ôemªf
.
d©aLí
 == 4)

627 if((
ôemªf
.
codeTy≥
 == 2))

629 
ST_UINT32
 
vÆue
 = 0;

630 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

631 
vÆue
 = 
	`FromBCD_DWORD
(value);

632 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT32
*)&
vÆue
));

634 if((
ôemªf
.
codeTy≥
 == 3))

636 
ST_UINT32
 
vÆue
 = 0;

637 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

638 
vÆue
 = 
	`FromBCD_DWORD
(
	`bsw≠32
(value));

639 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT32
*)&
vÆue
));

641 if((
ôemªf
.
codeTy≥
 == 0))

643 
ST_UINT32
 
vÆue
 = 0;

644 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

645 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT32
*)&
vÆue
));

647 if((
ôemªf
.
codeTy≥
 == 1))

649 
ST_UINT32
 
vÆue
 = 0;

650 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

651 
vÆue
 = 
	`bsw≠32
(value);

652 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT32
*)&
vÆue
));

654 if((
ôemªf
.
codeTy≥
 == 4))

656 
ST_UINT32
 
vÆue
 = 0;

657 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

658 
vÆue
 = 
	`ht⁄l1
(value);

659 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT32
*)&
vÆue
));

661 if((
ôemªf
.
codeTy≥
 == 5))

663 
ST_UINT32
 
vÆue
 = 0;

664 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

665 
vÆue
 = 
	`wsw≠32
(value);

666 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT32
*)&
vÆue
));

668 if((
ôemªf
.
codeTy≥
 == 6))

670 
ST_UINT32
 
vÆue
 = 0;

671 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

672 
ST_UINT16
* 
pbcdvÆue
 = (ST_UINT16*)&
vÆue
;

673 
fvÆue
 = (
ST_DOUBLE
)(
pbcdvÆue
[1]*10000 +Öbcdvalue[0]);

676 if(
ôemªf
.
d©aLí
 == 8)

678 if((
ôemªf
.
codeTy≥
 == 10))

680 
ST_UINT64
 
vÆue
 = 0;

681 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

682 
ST_UINT16
* 
pbcdvÆue
 = (ST_UINT16*)&
vÆue
;

683 
fvÆue
 = (
ST_DOUBLE
)(
	`bsw≠16
(
pbcdvÆue
[3])*1000000000000 + bswap16(pbcdvalue[2])*100000000 + bswap16(pbcdvalue[1])*10000 + bswap16(pbcdvalue[0]));

686 if(
ôemªf
.
c€ficõ¡
 != 0)

688 
fvÆue
 = fvÆuê* 
ôemªf
.
c€ficõ¡
;

690 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, 
fvÆue
);

692 
	}
}

694 
	gCModbusRTU
::
	$Pro˚ssMem‹yByã
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

696 
	`Pro˚ssMem‹ySByã
(
buf
, 
ôemªf
);

697 
	}
}

699 
	gCModbusRTU
::
	$Pro˚ssMem‹yUI¡16
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

701 
ST_FLOAT
 
fvÆue
 = 0;

702 if(
ôemªf
.
d©aLí
 == 1)

704 
ST_BYTE
 
vÆue
 = *(
buf
 + 
ôemªf
.
addr
);

705 if((
ôemªf
.
codeTy≥
 == 2) || (itemref.codeType == 3))

707 
fvÆue
 = 
	`FromBCD_BYTE
(
vÆue
);

709 
fvÆue
 = (
ST_FLOAT
)(
vÆue
);

711 if(
ôemªf
.
d©aLí
 == 2)

713 if((
ôemªf
.
codeTy≥
 == 2))

715 
ST_UINT16
 
vÆue
 = 0;

716 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

717 
fvÆue
 = 
	`FromBCD_WORD
(
vÆue
);

719 if((
ôemªf
.
codeTy≥
 == 3))

721 
ST_UINT16
 
vÆue
 = 0;

722 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

723 
fvÆue
 = 
	`FromBCD_WORD
(
	`bsw≠16
(
vÆue
));

725 if((
ôemªf
.
codeTy≥
 == 0))

727 
ST_UINT16
 
vÆue
 = 0;

728 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

729 
fvÆue
 = (
ST_FLOAT
)
vÆue
;

731 if((
ôemªf
.
codeTy≥
 == 1))

733 
ST_UINT16
 
vÆue
 = 0;

734 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

735 
fvÆue
 = (
ST_FLOAT
)
	`bsw≠16
(
vÆue
);

738 if(
ôemªf
.
d©aLí
 == 4)

740 if((
ôemªf
.
codeTy≥
 == 2))

742 
ST_UINT32
 
vÆue
 = 0;

743 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

744 
fvÆue
 = 
	`FromBCD_DWORD
(
vÆue
);

746 if((
ôemªf
.
codeTy≥
 == 3))

748 
ST_UINT32
 
vÆue
 = 0;

749 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

750 
fvÆue
 = 
	`FromBCD_DWORD
(
	`bsw≠32
(
vÆue
));

752 if((
ôemªf
.
codeTy≥
 == 0))

754 
ST_UINT32
 
vÆue
 = 0;

755 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

756 
fvÆue
 = (
ST_FLOAT
)
vÆue
;

758 if((
ôemªf
.
codeTy≥
 == 1))

760 
ST_UINT32
 
vÆue
 = 0;

761 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

762 
fvÆue
 = 
	`bsw≠32
(
vÆue
);

764 if((
ôemªf
.
codeTy≥
 == 4))

766 
ST_UINT32
 
vÆue
 = 0;

767 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

768 
fvÆue
 = 
	`ht⁄l1
(
vÆue
);

770 if((
ôemªf
.
codeTy≥
 == 5))

772 
ST_UINT32
 
vÆue
 = 0;

773 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

774 
fvÆue
 = 
	`wsw≠32
(
vÆue
);

776 if((
ôemªf
.
codeTy≥
 == 6))

778 
ST_UINT32
 
vÆue
 = 0;

779 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

780 
ST_UINT16
* 
pbcdvÆue
 = (ST_UINT16*)&
vÆue
;

781 
fvÆue
 = (
ST_FLOAT
)(
pbcdvÆue
[1]*10000 +Öbcdvalue[0]);

784 if(
ôemªf
.
d©aLí
 == 8)

786 if((
ôemªf
.
codeTy≥
 == 10))

788 
ST_UINT64
 
vÆue
 = 0;

789 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

790 
ST_UINT16
* 
pbcdvÆue
 = (ST_UINT16*)&
vÆue
;

791 
fvÆue
 = (
ST_FLOAT
)(
	`bsw≠16
(
pbcdvÆue
[3])*1000000000000 + bswap16(pbcdvalue[2])*100000000 + bswap16(pbcdvalue[1])*10000 + bswap16(pbcdvalue[0]));

794 if(
ôemªf
.
c€ficõ¡
 != 0)

796 
fvÆue
 = fvÆuê* 
ôemªf
.
c€ficõ¡
;

798 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, 
fvÆue
);

800 
	}
}

802 
	gCModbusRTU
::
	$Pro˚ssMem‹yUI¡32
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

804 
ST_DOUBLE
 
fvÆue
 = 0;

805 if(
ôemªf
.
d©aLí
 == 1)

807 
ST_BYTE
 
vÆue
 = *(
buf
 + 
ôemªf
.
addr
);

808 if((
ôemªf
.
codeTy≥
 == 2) || (itemref.codeType == 3))

810 
fvÆue
 = 
	`FromBCD_BYTE
(
vÆue
);

812 
fvÆue
 = (
ST_DOUBLE
)(
vÆue
);

814 if(
ôemªf
.
d©aLí
 == 2)

816 if((
ôemªf
.
codeTy≥
 == 2))

818 
ST_UINT16
 
vÆue
 = 0;

819 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

820 
fvÆue
 = 
	`FromBCD_WORD
(
vÆue
);

822 if((
ôemªf
.
codeTy≥
 == 3))

824 
ST_UINT16
 
vÆue
 = 0;

825 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

826 
fvÆue
 = 
	`FromBCD_WORD
(
	`bsw≠16
(
vÆue
));

828 if((
ôemªf
.
codeTy≥
 == 0))

830 
ST_UINT16
 
vÆue
 = 0;

831 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

832 
fvÆue
 = (
ST_DOUBLE
)
vÆue
;

834 if((
ôemªf
.
codeTy≥
 == 1))

836 
ST_UINT16
 
vÆue
 = 0;

837 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

838 
fvÆue
 = 
	`bsw≠16
(
vÆue
);

841 if(
ôemªf
.
d©aLí
 == 4)

843 if((
ôemªf
.
codeTy≥
 == 2))

845 
ST_UINT32
 
vÆue
 = 0;

846 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

847 
fvÆue
 = 
	`FromBCD_DWORD
(
vÆue
);

849 if((
ôemªf
.
codeTy≥
 == 3))

851 
ST_UINT32
 
vÆue
 = 0;

852 
	`mem˝y
(&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

853 
fvÆue
 = 
	`FromBCD_DWORD
(
	`bsw≠32
(
vÆue
));

855 if((
ôemªf
.
codeTy≥
 == 0))

857 
ST_UINT32
 
vÆue
 = 0;

858 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

859 
fvÆue
 = (
ST_DOUBLE
)
vÆue
;

861 if((
ôemªf
.
codeTy≥
 == 1))

863 
ST_UINT32
 
vÆue
 = 0;

864 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

865 
fvÆue
 = 
	`bsw≠32
(
vÆue
);

867 if((
ôemªf
.
codeTy≥
 == 4))

869 
ST_UINT32
 
vÆue
 = 0;

870 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

871 
fvÆue
 = 
	`ht⁄l1
(
vÆue
);

873 if((
ôemªf
.
codeTy≥
 == 5))

875 
ST_UINT32
 
vÆue
 = 0;

876 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

877 
fvÆue
 = 
	`wsw≠32
(
vÆue
);

879 if((
ôemªf
.
codeTy≥
 == 6))

881 
ST_UINT32
 
vÆue
 = 0;

882 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

883 
ST_UINT16
* 
pbcdvÆue
 = (ST_UINT16*)&
vÆue
;

884 
fvÆue
 = (
ST_DOUBLE
)(
pbcdvÆue
[1]*10000 +Öbcdvalue[0]);

887 if(
ôemªf
.
d©aLí
 == 8)

889 if((
ôemªf
.
codeTy≥
 == 10))

891 
ST_UINT64
 
vÆue
 = 0;

892 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, (value));

893 
ST_UINT16
* 
pbcdvÆue
 = (ST_UINT16*)&
vÆue
;

894 
fvÆue
 = (
ST_DOUBLE
)(
	`bsw≠16
(
pbcdvÆue
[3])*1000000000000 + bswap16(pbcdvalue[2])*100000000 + bswap16(pbcdvalue[1])*10000 + bswap16(pbcdvalue[0]));

897 if(
ôemªf
.
c€ficõ¡
 != 0)

899 
fvÆue
 = fvÆuê* 
ôemªf
.
c€ficõ¡
;

901 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, 
fvÆue
);

903 
	}
}

905 
	gCModbusRTU
::
	$Pro˚ssMem‹ySögÀ
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

907 
ST_FLOAT
 
fvÆue
 = 0;

908 if(
ôemªf
.
d©aLí
 == 1)

910 
ST_BYTE
 
vÆue
 = *(
buf
 + 
ôemªf
.
addr
);

911 if((
ôemªf
.
codeTy≥
 == 2) || (itemref.codeType == 3))

913 
fvÆue
 = 
	`FromBCD_BYTE
(
vÆue
);

915 
fvÆue
 = (
ST_FLOAT
)(*((
ST_CHAR
*)&
vÆue
));

917 if(
ôemªf
.
d©aLí
 == 2)

919 if((
ôemªf
.
codeTy≥
 == 2))

921 
ST_UINT16
 
vÆue
 = 
	`FromBCD_WORD
(
c⁄vît
::
byãs_to
<
uöt16_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

922 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT16
*)&
vÆue
));

924 if((
ôemªf
.
codeTy≥
 == 3))

926 
ST_UINT16
 
vÆue
 = 
	`FromBCD_WORD
(
	`bsw≠16
(
c⁄vît
::
byãs_to
<
uöt16_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
)));

927 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT16
*)&
vÆue
));

929 if((
ôemªf
.
codeTy≥
 == 0))

931 
ST_UINT16
 
vÆue
 = 
c⁄vît
::
byãs_to
<
uöt16_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
);

932 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT16
*)&
vÆue
));

934 if((
ôemªf
.
codeTy≥
 == 1))

936 
ST_UINT16
 
vÆue
 = 
	`bsw≠16
(
c⁄vît
::
byãs_to
<
uöt16_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

937 
fvÆue
 = (
ST_FLOAT
)(*((
ST_INT16
*)&
vÆue
));

940 if(
ôemªf
.
d©aLí
 == 4)

942 if((
ôemªf
.
codeTy≥
 == 2))

944 
ST_UINT32
 
vÆue
 = 
	`FromBCD_DWORD
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

945 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

947 if((
ôemªf
.
codeTy≥
 == 3))

949 
ST_UINT32
 
vÆue
 = 
	`FromBCD_DWORD
(
	`bsw≠32
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
)));

950 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

952 if((
ôemªf
.
codeTy≥
 == 0))

954 
ST_UINT32
 
vÆue
 = 
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
);

955 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

957 if((
ôemªf
.
codeTy≥
 == 1))

959 
ST_UINT32
 
vÆue
 = 
	`bsw≠32
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

960 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

962 if((
ôemªf
.
codeTy≥
 == 4))

964 
ST_UINT32
 
vÆue
 = 
	`ht⁄l1
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

965 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

967 if((
ôemªf
.
codeTy≥
 == 5))

969 
ST_UINT32
 
vÆue
 = 
	`wsw≠32
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

970 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

974 if(
ôemªf
.
c€ficõ¡
 != 0)

976 
fvÆue
 = fvÆuê* 
ôemªf
.
c€ficõ¡
;

978 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, 
fvÆue
);

980 
	}
}

982 
	gCModbusRTU
::
	$Pro˚ssMem‹yBoﬁón
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

984 
ST_BYTE
 
vÆue
 = (
ST_BOOLEAN
)(*(
buf
 + 
ôemªf
.
addr
));

985 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, 
vÆue
);

986 
	}
}

988 
	gCModbusRTU
::
	$Pro˚ssMem‹ySåög
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

991 
	}
}

993 
	gCModbusRTU
::
	$Pro˚ssMem‹yByãs
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

996 
	}
}

998 
	gCModbusRTU
::
	$Pro˚ssMem‹yDoubÀ
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

1000 
ST_DOUBLE
 
fvÆue
 = 0;

1001 if(
ôemªf
.
d©aLí
 == 1)

1003 
ST_BYTE
 
vÆue
 = *(
buf
 + 
ôemªf
.
addr
);

1004 if((
ôemªf
.
codeTy≥
 == 2) || (itemref.codeType == 3))

1006 
fvÆue
 = 
	`FromBCD_BYTE
(
vÆue
);

1008 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_CHAR
*)&
vÆue
));

1010 if(
ôemªf
.
d©aLí
 == 2)

1012 if((
ôemªf
.
codeTy≥
 == 2))

1014 
ST_UINT16
 
vÆue
 = 
	`FromBCD_WORD
(
c⁄vît
::
byãs_to
<
uöt16_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

1015 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT16
*)&
vÆue
));

1017 if((
ôemªf
.
codeTy≥
 == 3))

1019 
ST_UINT16
 
vÆue
 = 
	`FromBCD_WORD
(
	`bsw≠16
(
c⁄vît
::
byãs_to
<
uöt16_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
)));

1020 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT16
*)&
vÆue
));

1022 if((
ôemªf
.
codeTy≥
 == 0))

1024 
ST_UINT16
 
vÆue
 = 
c⁄vît
::
byãs_to
<
uöt16_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
);

1025 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT16
*)&
vÆue
));

1027 if((
ôemªf
.
codeTy≥
 == 1))

1029 
ST_UINT16
 
vÆue
 = 
	`bsw≠16
(
c⁄vît
::
byãs_to
<
uöt16_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

1030 
fvÆue
 = (
ST_DOUBLE
)(*((
ST_INT16
*)&
vÆue
));

1033 if(
ôemªf
.
d©aLí
 == 4)

1035 if((
ôemªf
.
codeTy≥
 == 2))

1037 
ST_UINT32
 
vÆue
 = 
	`FromBCD_DWORD
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

1038 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

1040 if((
ôemªf
.
codeTy≥
 == 3))

1042 
ST_UINT32
 
vÆue
 = 
	`FromBCD_DWORD
(
	`bsw≠32
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
)));

1043 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

1045 if((
ôemªf
.
codeTy≥
 == 0))

1047 
ST_UINT32
 
vÆue
 = 
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
);

1048 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

1050 if((
ôemªf
.
codeTy≥
 == 1))

1052 
ST_UINT32
 
vÆue
 = 
	`bsw≠32
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

1053 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

1055 if((
ôemªf
.
codeTy≥
 == 4))

1057 
ST_UINT32
 
vÆue
 = 
	`ht⁄l1
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

1058 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

1061 if((
ôemªf
.
codeTy≥
 == 5))

1063 
ST_UINT32
 
vÆue
 = 
	`wsw≠32
(
c⁄vît
::
byãs_to
<
uöt32_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

1064 
fvÆue
 = *((
ST_FLOAT
*)&
vÆue
);

1067 i‡(
ôemªf
.
d©aLí
 == 8)

1069 
ôemªf
.
codeTy≥
) {

1071 
ST_UINT64
 
vÆue
 = 
c⁄vît
::
byãs_to
<
uöt64_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
);

1072 
fvÆue
 = (*((
ST_DOUBLE
*)&
vÆue
));

1075 
ST_UINT64
 
vÆue
 = 
	`bsw≠64
 (
c⁄vît
::
byãs_to
<
uöt64_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

1076 
fvÆue
 = (*((
ST_DOUBLE
*)&
vÆue
));

1081 
ST_UINT64
 
vÆue
 = 
	`wsw≠64
 (
c⁄vît
::
byãs_to
<
uöt64_t
>(
buf
 + 
ôemªf
.
addr
, iãmªf.
d©aLí
));

1082 
fvÆue
 = (*((
ST_DOUBLE
*)&
vÆue
));

1087 if(
ôemªf
.
c€ficõ¡
 != 0)

1088 
fvÆue
 = fvÆuê* 
ôemªf
.
c€ficõ¡
;

1090 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, 
fvÆue
);

1092 
	}
}

1094 
	gCModbusRTU
::
	$Pro˚ssMem‹yDecimÆ
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

1097 
	}
}

1099 
	gCModbusRTU
::
	$Pro˚ssMem‹yD©eTime
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

1101 if(
ôemªf
.
d©aLí
 == 8)

1105 
	}
}

1107 
boﬁ
 
	$ByãsToUI¡64
 (c⁄° 
ST_BYTE
* 
buf
, 
ST_INT
 
codëy≥
, 
ST_UINT64
& 
vÆue
)

1109 
codëy≥
) {

1111 
	`mem˝y
 (&
vÆue
, 
buf
, (value));

1112 }  
åue
;

1114 
vÆue
 = 
	`bsw≠64
 (
c⁄vît
::
byãs_to
<
uöt64_t
>(
buf
, (uint64_t)));

1115 }  
åue
;

1117 }  
Ál£
;

1119 
vÆue
 = 
	`wsw≠64
 (
c⁄vît
::
byãs_to
<
uöt64_t
>(
buf
, (uint64_t)));

1120 }  
åue
;

1122  
Ál£
;

1123 
	}
}

1125 
	gCModbusRTU
::
	$Pro˚ssMem‹yI¡64
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

1127 i‡(
ôemªf
.
d©aLí
 < 8) {

1128 
	`Pro˚ssMem‹yI¡32
 (
buf
, 
ôemªf
);

1131 
ST_INT64
 
vÆue
 = 0;

1132 
ST_UINT64
& 
vÆªf
 = *((ST_UINT64*)&
vÆue
);

1133 i‡(
	`ByãsToUI¡64
 (
buf
 + 
ôemªf
.
addr
, iãmªf.
codeTy≥
, 
vÆªf
)) {

1134 if(
ôemªf
.
c€ficõ¡
 != 0)

1135 
vÆue
 *
ôemªf
.
c€ficõ¡
;

1136 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, (
ST_DOUBLE
)
vÆue
);

1138 
	}
}

1140 
	gCModbusRTU
::
	$Pro˚ssMem‹yUI¡64
(
ST_BYTE
* 
buf
, c⁄° 
ST_D©aAªaIãm
& 
ôemªf
)

1142 i‡(
ôemªf
.
d©aLí
 < 6) {

1143 
	`Pro˚ssMem‹yUI¡32
 (
buf
, 
ôemªf
);

1146 
ST_UINT64
 
vÆue
 = 0;

1147 i‡(
ôemªf
.
d©aLí
 == 6) {

1148 
ôemªf
.
codeTy≥
) {

1150 
	`mem˝y
 (&
vÆue
, 
buf
 + 
ôemªf
.
addr
, 6);

1151 if(
ôemªf
.
c€ficõ¡
 != 0)

1152 
vÆue
 *
ôemªf
.
c€ficõ¡
;

1153 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, (
ST_DOUBLE
)
vÆue
);

1156 
vÆue
 = (
ST_UINT64
)(
buf
[
ôemªf
.
addr
 ]) * 0x10000000000

1157 + (
ST_UINT64
)(
buf
[
ôemªf
.
addr
 + 1]) * 0x100000000

1158 + (
ST_UINT64
)(
buf
[
ôemªf
.
addr
 + 2]) * 0x1000000

1159 + (
ST_UINT64
)(
buf
[
ôemªf
.
addr
 + 3]) * 0x10000

1160 + (
ST_UINT64
)(
buf
[
ôemªf
.
addr
 + 4]) * 0x100

1161 + (
ST_UINT64
)(
buf
[
ôemªf
.
addr
 + 5]);

1162 if(
ôemªf
.
c€ficõ¡
 != 0)

1163 
vÆue
 *
ôemªf
.
c€ficõ¡
;

1164 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, (
ST_DOUBLE
)
vÆue
);

1169 i‡(
	`ByãsToUI¡64
 (
buf
 + 
ôemªf
.
addr
, iãmªf.
codeTy≥
, 
vÆue
)) {

1170 if(
ôemªf
.
c€ficõ¡
 != 0)

1171 
vÆue
 *
ôemªf
.
c€ficõ¡
;

1172 
this
->
	`Upd©eVÆue
(
ôemªf
.
id
, (
ST_DOUBLE
)
vÆue
);

1174 
	}
}

1176 
	gCModbusRTU
::
	$SídRódCmd
(
ST_BYTE
 
code
,
ST_UINT
 
ªadAddr
,ST_UINT 
cou¡
)

1178 
ST_BYTE
 
£ndbuf
[8];

1179 
£ndbuf
[0] = (
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
Addªss
;

1180 
£ndbuf
[1] = 
code
;

1181 
	`FûlWORD
(
£ndbuf
 + 2,
ªadAddr
);

1182 
	`FûlWORD
(
£ndbuf
 + 4,
cou¡
);

1183 *(
ST_UINT16
*)(
£ndbuf
 + 6Ë
	`gë_¸c16
(sendbuf,6);

1184 
this
->
	`Síd
(
£ndbuf
,8);

1185 
	}
}

1187 
	gCModbusRTU
::
	$SídYK
(
ST_UINT
 
wrôeAddr
,
ST_INT
 
d©a
)

1189 
ST_BYTE
 
£ndbuf
[32] = {0};

1190 
Àn
 = 0;

1192 
£ndbuf
[0] = (
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
Addªss
;

1193 
£ndbuf
[1] = 0x06;

1194 
	`FûlWORD
(
£ndbuf
 + 2,
wrôeAddr
);

1195 
	`FûlWORD
(
£ndbuf
 + 4,
d©a
);

1196 
Àn
 = 6;

1197 *(
ST_UINT16
*)(
£ndbuf
 + 
Àn
Ë
	`gë_¸c16
(sendbuf,len);

1198 
this
->
	`Síd
(
£ndbuf
,
Àn
+2);

1209 
	}
}

1211 
	gCModbusRTU
::
	$SídPªYK
(
ST_UINT
 
wrôeAddr
,
ST_BOOLEAN
 
bIsOn
)

1213 
ST_BYTE
 
£ndbuf
[32] = {0};

1214 
Àn
 = 0;

1216 
£ndbuf
[0] = (
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
Addªss
;

1217 
£ndbuf
[1] = 0x06;

1218 
	`FûlWORD
(
£ndbuf
 + 2,
wrôeAddr
);

1219 
	`FûlWORD
(
£ndbuf
 + 4,
bIsOn
);

1220 
Àn
 = 6;

1221 *(
ST_UINT16
*)(
£ndbuf
 + 
Àn
Ë
	`gë_¸c16
(sendbuf,len);

1222 
this
->
	`Síd
(
£ndbuf
,
Àn
+2);

1224 
	}
}

1226 
	gCModbusRTU
::
	$SídYT
(
ST_UINT
 
wrôeAddr
,ST_UINT 
wIndex
,
ST_BOOLEAN
 
bIsOn
)

1228 
ST_BYTE
 
£ndbuf
[256];

1229 
£ndbuf
[0] = (
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
Addªss
;

1230 
£ndbuf
[1] = 0x05;

1231 
	`FûlWORD
(
£ndbuf
 + 2,
wrôeAddr
);

1232 if(
bIsOn
)

1233 
£ndbuf
[4] = 0xFF;

1235 
£ndbuf
[4] = 0x00;

1236 
£ndbuf
[5] = 0x00;

1237 *(
ST_UINT16
*)(
£ndbuf
 + 6Ë
	`gë_¸c16
(sendbuf,6);

1238 
this
->
	`Síd
(
£ndbuf
,8);

1240 
	}
}

1241 
	gCModbusRTU
::
	$SídSögÀWrôeCmd
(
ST_INT
 
d©a
,ST_INT 
ªadAddr
,ST_INT 
nTy≥
)

1244 
ST_BYTE
 
£ndbuf
[256];

1245 
ST_INT
 
Àn
 = 0;

1247 if(
nTy≥
 == 1)

1249 
£ndbuf
[0] = (
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
Addªss
;

1250 
£ndbuf
[1] = 0x10;

1251 
	`FûlWORD
(
£ndbuf
 + 2,
ªadAddr
);

1252 
£ndbuf
[4] = 0x00;

1253 
£ndbuf
[5] = 0x01;

1254 
£ndbuf
[6] = 0x02;

1255 
	`FûlWORD
(
£ndbuf
 + 7,
d©a
);

1256 
Àn
 = 9;

1257 *(
ST_UINT16
*)(
£ndbuf
 + 
Àn
Ë
	`gë_¸c16
(sendbuf,len);

1258 
this
->
	`Síd
(
£ndbuf
,
Àn
+2);

1260 if(
nTy≥
 == 0)

1263 
£ndbuf
[0] = (
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
Addªss
;

1264 
£ndbuf
[1] = 0x06;

1265 
	`FûlWORD
(
£ndbuf
 + 2,
ªadAddr
);

1266 
	`FûlWORD
(
£ndbuf
 + 4,
d©a
);

1267 
Àn
 = 6;

1268 *(
ST_UINT16
*)(
£ndbuf
 + 
Àn
Ë
	`gë_¸c16
(sendbuf,len);

1269 
this
->
	`Síd
(
£ndbuf
,
Àn
+2);

1300 
	}
}

1302 
	gCModbusRTU
::
	$SídWrôeCmd
(
ST_UCHAR
* 
pD©a
,
ST_UINT
 
d©aLí
,ST_UINT 
addr
)

1304 if((
d©aLí
>=1024) || (dataLen<=0)) ;

1305 
ST_BYTE
 
£ndbuf
[1024];

1306 
ST_INT
 
i
=0;i<1024;i++)

1307 
£ndbuf
[
i
] = 0xff;

1308 
ST_INT
 
Àn
 = 0;

1309 
ST_INT
 
nd©aLí
 = (
d©aLí
%2)?(dataLen/2+1):(dataLen/2);

1310 
£ndbuf
[0] = (
ST_BYTE
)
this
->
	`GëDevi˚
()->
	`GëDevi˚Info
()->
Addªss
;

1311 
£ndbuf
[1] = 0x10;

1312 
	`FûlWORD
(
£ndbuf
 + 2,
addr
);

1313 
	`FûlWORD
(
£ndbuf
 + 4,
nd©aLí
);

1314 
£ndbuf
[6] = 
nd©aLí
*2;

1315 
	`mem˝y
(
£ndbuf
 + 7,
pD©a
,
d©aLí
);

1316 
Àn
 = 7 + 
nd©aLí
*2;

1317 *(
ST_UINT16
*)(
£ndbuf
 + 
Àn
Ë
	`gë_¸c16
(sendbuf,len);

1318 
this
->
	`Síd
(
£ndbuf
,
Àn
 + 2);

1319 
	}
}

1321 
	gCModbusRTU
::
	$FûlWORD
(
ST_BYTE
* 
buf
,
ST_UINT
 
v
)

1323 
ST_BYTE
* 
pv
 = (ST_BYTE*)&
v
;

1324 
buf
[0] = 
pv
[1];

1325 
buf
[1] = 
pv
[0];

1326 
	}
}

1328 
ST_UINT
 
	gCModbusRTU
::
	$GëAµWORDVÆue
(
ST_UINT
 
v
,
ST_INT
 
codëy≥
)

1330 if(
codëy≥
 == 1 || codetype == 4)

1332  
	`bsw≠16
(
v
);

1334 if(
codëy≥
 == 2)

1336  
	`FromBCD_WORD
(
v
);

1338  
v
;

1339 
	}
}

1341 
ST_UINT32
 
	gCModbusRTU
::
	$ht⁄l1
(
ST_UINT32
 
dv
)

1343 
ST_UINT16
 
dwHTemp
 = (ST_UINT16)((
dv
&0xffff0000)>>16);

1344 
ST_UINT16
 
dwLTemp
 = (ST_UINT16)(
dv
&0x0000ffff);

1345 
ST_UINT16
 
wLTemp
 = 
	`bsw≠16
(
dwLTemp
);

1346 
ST_UINT16
 
wHTemp
 = 
	`bsw≠16
(
dwHTemp
);

1347 
ST_UINT32
 
dwTemp
 = 
wHTemp
;

1348  ((
dwTemp
<<16)|
wLTemp
);

1349 
	}
}

1351 
	gCModbusRTU
::
	$SídWrôeCmd
(
ST_UCHAR
* 
pD©a
,
ST_UINT
 
d©aLí
)

1353 
ST_BYTE
 
£nd‰ame
[1024];

1354 if(
d©aLí
>=1024) ;

1355 
ST_UINT
 
i
 = 0; i < 
d©aLí
; i++)

1357 
£nd‰ame
[
i
] = 
pD©a
[i];

1359 
this
->
	`Síd
(
£nd‰ame
, 
d©aLí
);

1360 
	}
}

	@
1
.
1
/usr/include
2
166
/home/zengrong/wedo/protocols/txjprotocolmodbusrtu_zhu_ZGDZ_06/include/CModbusRTU.h
/home/zengrong/wedo/protocols/txjprotocolmodbusrtu_zhu_ZGDZ_06/src/CModbusRTU.cpp
